id: java-multithread-deadlock-fix
title: Diagnose and Fix Deadlock and Race Conditions in Java Application
description: |
  You are tasked with debugging a legacy Java application used for processing configuration files. The application, comprised of `Main.java`, `Worker.java`, and `SharedDataStore.java`, utilizes multiple threads to process data concurrently. However, users have reported two critical issues:
  1. The application frequently hangs indefinitely during execution (Deadlock).
  2. When it does finish, the final calculated totals are inconsistent across runs (Race Condition).

  Your workflow is as follows:
  1. Compile and run the application using the provided `compile.sh` and `run.sh` scripts (or manually via `javac`) to reproduce the hanging behavior.
  2. While the application is hung, use terminal tools like `jps` to find the Process ID and `jstack` to generate a thread dump. Analyze the dump to identify the deadlock and the specific lines of code causing the circular dependency.
  3. Analyze the source code to identify the race condition in the shared data accumulation logic.
  4. Edit the source code (using `vi`, `nano`, or similar) to resolve both the deadlock and the race condition. You may use `synchronized` blocks, `ReentrantLock`, or atomic variables as you see fit, provided the data integrity is maintained.
  5. Verify the fix by running the application multiple times to ensure it terminates successfully and produces the consistent, correct total.

domain: Bug Fixes
difficulty: medium
objectives:
  - Identify the cause of the application deadlock using JVM diagnostic tools.
  - Refactor the code to eliminate the circular wait condition causing the deadlock.
  - Identify and fix the race condition in the `SharedDataStore` class to ensure thread-safe updates.
  - Ensure the application compiles without errors.
  - Ensure the application executes to completion without hanging and prints the correct deterministic result.
inputs:
  - src/Main.java: Entry point setting up the thread pool.
  - src/Worker.java: Runnable implementation that processes tasks.
  - src/SharedDataStore.java: Class holding shared state/counters.
  - config/data.csv: Input data file simulating workload.
  - scripts/compile.sh: Helper script to compile the source.
  - scripts/run.sh: Helper script to execute the application.
expected_outputs:
  - The application stdout must end with "Processing Complete. Final Total: 20000".
  - The application must exit with status code 0.
  - The `jstack` output on the fixed application should not show threads in "BLOCKED" state due to deadlock.
edge_cases:
  - The fix must handle high thread contention without losing data updates.
  - The solution must prevent deadlock regardless of thread scheduling order (e.g., avoiding nested locks in inconsistent orders).
constraints:
  - The task must be solved entirely offline within the provided container.
  - You must not change the logic of *what* is calculated, only *how* it is synchronized.
  - External libraries are not available; use standard JDK 11+ concurrency utilities (java.util.concurrent).
max_agent_timeout_sec: 900
max_test_timeout_sec: 300
hints:
  - Use `jps -l` to find the Java process ID quickly.
  - Run `jstack <pid>` > `dump.txt` to capture the state of hung threads. Look for "Found one Java-level deadlock" at the bottom of the dump.
  - Check if `SharedDataStore` uses `synchronized` on methods or blocks, and if `Worker` threads acquire locks in a different order (e.g., Lock A then Lock B vs. Lock B then Lock A).
  - For the race condition, consider if `++` operations on primitives are atomic (they are not) and look into `AtomicInteger` or proper synchronization.