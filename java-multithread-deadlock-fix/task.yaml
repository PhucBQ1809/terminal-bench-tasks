author_email: "dev@example.com"
author_name: "Terminal-Bench Contributor"
category: "software_engineering"
difficulty: "hard"
disable_asciinema: false
estimated_duration_sec: 1200.0
expert_time_estimate_min: 15
instruction: |
  **Context**
  You are a backend engineer maintaining a legacy financial transaction simulator. The application, `BankService`, is designed to handle high-volume concurrent transfers between accounts using multi-threading. However, reports indicate that the process intermittently "freezes" (hangs) when under heavy load, stopping all transaction processing without crashing or throwing errors.

  Preliminary investigation suggests a threading issue where the application enters a state of resource starvation or circular wait.

  **Environment & Files**
  - `src/BankService.java`: The source code containing the `transfer()` logic and synchronization blocks.
  - `reproduce_issue.sh`: A script that compiles the code and spawns multiple threads to simulate high concurrency.
  - Standard JDK tools are available (javac, java, jstack, jcmd, etc.).

  **The Failure**
  When you run `bash reproduce_issue.sh`, the application will start processing transactions. After a short period, it will likely stop printing "Transaction completed" logs, but the process will remain active (hanging).

  **Objectives**
  1. Analyze the running process when it hangs to confirm the cause (suspected deadlock).
  2. Identify the specific circular dependency in the locking logic within `src/BankService.java`.
  3. Refactor the `transfer` method in `src/BankService.java` to resolve the deadlock while maintaining thread safety.
  4. Verify the fix by running `reproduce_issue.sh` again; it should run to completion (processing all 1000 planned transactions) without freezing.

  **Constraints**
  - You must only modify `src/BankService.java`.
  - You cannot simply remove synchronization; the transfer must remain thread-safe.
  - You must solve this using standard JDK libraries only (no external dependencies).
  - The solution must be deterministic (it must not rely on Thread.sleep hacks to avoid the race condition).

  **Hints & Troubleshooting**
  - Use `jps` to find the Process ID (PID) of the hanging application.
  - Use `jstack <PID>` to capture a thread dump. Look specifically for "Found one Java-level deadlock" at the bottom of the output.
  - Examine the order in which locks (account objects) are acquired. A common deadlock fix involves enforcing a global lock ordering based on unique account IDs.
  - Ensure you handle exceptions properly so locks are always released (e.g., inside a `finally` block if using explicit Locks, though `synchronized` handles this automatically).
junior_time_estimate_min: 30
max_agent_timeout_sec: 600
max_test_timeout_sec: 300
parser_name: "pytest"
run_tests_in_same_shell: false
tags:
  - "java"
  - "debugging"
  - "concurrency"
  - "deadlock"
  - "cli_tools"